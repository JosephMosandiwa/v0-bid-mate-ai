{"version":3,"sources":["../../../lib/engines/documind/errors.ts","../../../lib/engines/documind/constants.ts","../../../lib/engines/documind/utils/position-mapper.ts","../../../lib/engines/documind/modules/pdf-parser.ts","../../../lib/engines/documind/modules/layout-analyzer.ts","../../../lib/engines/documind/modules/ocr-engine.ts","../../../lib/engines/documind/utils/fingerprint.ts","../../../lib/engines/documind/utils/validation.ts","../../../lib/engines/documind/index.ts"],"sourcesContent":["// ============================================\r\n// DOCUMIND ENGINE - ERROR HANDLING\r\n// ============================================\r\n\r\nimport type { DocuMindError, ErrorCode } from \"./types\"\r\n\r\n// Error factory functions\r\nexport function createError(\r\n  code: ErrorCode,\r\n  message: string,\r\n  details?: Record<string, any>,\r\n  recoverable = false,\r\n): DocuMindError {\r\n  return {\r\n    code,\r\n    message,\r\n    details,\r\n    recoverable,\r\n  }\r\n}\r\n\r\n// Pre-defined errors\r\nexport const Errors = {\r\n  // File errors\r\n  fileTooLarge: (maxSize: number, actualSize: number) =>\r\n    createError(\r\n      \"FILE_TOO_LARGE\",\r\n      `File size ${actualSize} bytes exceeds maximum ${maxSize} bytes`,\r\n      { max_size: maxSize, actual_size: actualSize },\r\n      false,\r\n    ),\r\n\r\n  unsupportedFormat: (format: string) =>\r\n    createError(\"UNSUPPORTED_FORMAT\", `File format '${format}' is not supported`, { format }, false),\r\n\r\n  corruptedFile: (reason?: string) =>\r\n    createError(\"CORRUPTED_FILE\", reason || \"The file appears to be corrupted or invalid\", { reason }, false),\r\n\r\n  passwordProtected: () =>\r\n    createError(\"PASSWORD_PROTECTED\", \"The PDF is password protected. Please provide the password.\", undefined, true),\r\n\r\n  invalidPassword: () => createError(\"INVALID_PASSWORD\", \"The provided password is incorrect\", undefined, true),\r\n\r\n  // Processing errors\r\n  parseFailed: (stage: string, reason: string) =>\r\n    createError(\"PARSE_FAILED\", `Failed to parse document at stage '${stage}': ${reason}`, { stage, reason }, false),\r\n\r\n  ocrFailed: (reason: string) => createError(\"OCR_FAILED\", `OCR processing failed: ${reason}`, { reason }, true),\r\n\r\n  timeout: (stage: string, timeoutMs: number) =>\r\n    createError(\r\n      \"TIMEOUT\",\r\n      `Processing timed out at stage '${stage}' after ${timeoutMs}ms`,\r\n      { stage, timeout_ms: timeoutMs },\r\n      true,\r\n    ),\r\n\r\n  outOfMemory: () =>\r\n    createError(\"OUT_OF_MEMORY\", \"Document is too complex to process. Try reducing page count.\", undefined, false),\r\n\r\n  // Service errors\r\n  serviceUnavailable: (service: string) =>\r\n    createError(\"SERVICE_UNAVAILABLE\", `Service '${service}' is currently unavailable`, { service }, true),\r\n\r\n  rateLimited: (retryAfter: number) =>\r\n    createError(\r\n      \"RATE_LIMITED\",\r\n      `Rate limit exceeded. Please retry after ${retryAfter} seconds`,\r\n      { retry_after: retryAfter },\r\n      true,\r\n    ),\r\n\r\n  quotaExceeded: (quota: string) =>\r\n    createError(\"QUOTA_EXCEEDED\", `Quota '${quota}' has been exceeded`, { quota }, false),\r\n\r\n  // Validation errors\r\n  invalidRequest: (reason: string) => createError(\"INVALID_REQUEST\", `Invalid request: ${reason}`, { reason }, false),\r\n\r\n  missingRequiredField: (field: string) =>\r\n    createError(\"MISSING_REQUIRED_FIELD\", `Required field '${field}' is missing`, { field }, false),\r\n\r\n  invalidOptions: (option: string, reason: string) =>\r\n    createError(\"INVALID_OPTIONS\", `Invalid option '${option}': ${reason}`, { option, reason }, false),\r\n\r\n  // Not found errors\r\n  documentNotFound: (documentId: string) =>\r\n    createError(\"DOCUMENT_NOT_FOUND\", `Document '${documentId}' not found`, { document_id: documentId }, false),\r\n\r\n  templateNotFound: (templateId: string) =>\r\n    createError(\"TEMPLATE_NOT_FOUND\", `Template '${templateId}' not found`, { template_id: templateId }, false),\r\n\r\n  jobNotFound: (jobId: string) => createError(\"JOB_NOT_FOUND\", `Job '${jobId}' not found`, { job_id: jobId }, false),\r\n}\r\n\r\n// Error logging\r\nexport interface ErrorLogEntry {\r\n  document_id?: string\r\n  job_id?: string\r\n  app_id: string\r\n  request_id?: string\r\n  error_code: ErrorCode\r\n  error_message: string\r\n  stack_trace?: string\r\n  processing_stage?: string\r\n  file_info?: {\r\n    filename?: string\r\n    mime_type?: string\r\n    size?: number\r\n  }\r\n  occurred_at: string\r\n}\r\n\r\nexport function formatErrorLog(\r\n  error: DocuMindError,\r\n  context: {\r\n    document_id?: string\r\n    job_id?: string\r\n    app_id: string\r\n    request_id?: string\r\n    processing_stage?: string\r\n    file_info?: Record<string, any>\r\n  },\r\n): ErrorLogEntry {\r\n  return {\r\n    document_id: context.document_id,\r\n    job_id: context.job_id,\r\n    app_id: context.app_id,\r\n    request_id: context.request_id,\r\n    error_code: error.code,\r\n    error_message: error.message,\r\n    processing_stage: context.processing_stage,\r\n    file_info: context.file_info,\r\n    occurred_at: new Date().toISOString(),\r\n  }\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - CONSTANTS\r\n// ============================================\r\n\r\n// File size limits\r\nexport const MAX_FILE_SIZE = 50 * 1024 * 1024 // 50MB\r\nexport const MAX_PAGES = 500\r\nexport const MAX_FILE_SIZE_FOR_SYNC = 10 * 1024 * 1024 // 10MB - larger files go async\r\n\r\n// Supported MIME types\r\nexport const SUPPORTED_MIME_TYPES = [\r\n  \"application/pdf\",\r\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\", // .docx\r\n  \"application/msword\", // .doc\r\n  \"image/png\",\r\n  \"image/jpeg\",\r\n  \"image/tiff\",\r\n  \"image/webp\",\r\n] as const\r\n\r\nexport type SupportedMimeType = (typeof SUPPORTED_MIME_TYPES)[number]\r\n\r\n// File extensions mapping\r\nexport const MIME_TO_EXTENSION: Record<SupportedMimeType, string> = {\r\n  \"application/pdf\": \".pdf\",\r\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\": \".docx\",\r\n  \"application/msword\": \".doc\",\r\n  \"image/png\": \".png\",\r\n  \"image/jpeg\": \".jpg\",\r\n  \"image/tiff\": \".tiff\",\r\n  \"image/webp\": \".webp\",\r\n}\r\n\r\n// Processing timeouts (ms)\r\nexport const TIMEOUTS = {\r\n  parse: 60000, // 60 seconds\r\n  ocr_per_page: 10000, // 10 seconds per page\r\n  layout_analysis: 30000, // 30 seconds\r\n  total: 300000, // 5 minutes total\r\n}\r\n\r\n// Cache TTLs (seconds)\r\nexport const CACHE_TTL = {\r\n  parsed_document: 86400, // 24 hours\r\n  template_list: 3600, // 1 hour\r\n  fingerprint_match: 86400, // 24 hours\r\n}\r\n\r\n// OCR settings\r\nexport const OCR_CONFIG = {\r\n  default_language: \"eng\",\r\n  confidence_threshold: 0.6, // Below this, mark as low confidence\r\n  min_text_density: 0.01, // Below this, consider page as image/scanned\r\n}\r\n\r\n// Field detection settings\r\nexport const FIELD_DETECTION = {\r\n  min_line_length: 20, // Minimum pixels for a line to be considered\r\n  max_label_distance: 50, // Max pixels between label and field\r\n  min_confidence: 0.5, // Minimum confidence to include a field\r\n}\r\n\r\n// PDF coordinate system\r\nexport const PDF_POINTS_PER_INCH = 72\r\n\r\n// Common SA tender form codes\r\nexport const SA_TENDER_FORMS = {\r\n  SBD1: \"Invitation to Bid\",\r\n  SBD2: \"Tax Clearance Certificate Requirements\",\r\n  SBD3_1: \"Pricing Schedule - Firm Prices\",\r\n  SBD3_2: \"Pricing Schedule - Non-Firm Prices\",\r\n  SBD3_3: \"Pricing Schedule - Professional Services\",\r\n  SBD4: \"Declaration of Interest\",\r\n  SBD5: \"National Industrial Participation Programme\",\r\n  SBD6_1: \"Preference Points Claim Form - Procurement\",\r\n  SBD6_2: \"Declaration for Local Production and Content\",\r\n  SBD7_1: \"Contract Form - Purchase of Goods\",\r\n  SBD7_2: \"Contract Form - Lease of Goods\",\r\n  SBD7_3: \"Contract Form - Rendering of Services\",\r\n  SBD8: \"Declaration of Bidders Past SCM Practices\",\r\n  SBD9: \"Certificate of Independent Bid Determination\",\r\n  MBD1: \"Municipal Invitation to Bid\",\r\n  MBD2: \"Tax Clearance Requirements\",\r\n  MBD4: \"Declaration of Interest\",\r\n  MBD5: \"Declaration for Procurement\",\r\n  MBD6_1: \"Preference Points Claim Form\",\r\n  MBD7_1: \"Contract Form - Purchase\",\r\n  MBD8: \"Declaration of Bidders Past SCM Practices\",\r\n  MBD9: \"Certificate of Independent Bid Determination\",\r\n  CSD: \"Central Supplier Database\",\r\n  CIDB: \"Construction Industry Development Board\",\r\n} as const\r\n\r\n// Document type detection patterns\r\nexport const DOCUMENT_TYPE_PATTERNS = {\r\n  tender: [/tender/i, /bid/i, /rfq/i, /request for quotation/i, /invitation to/i, /procurement/i],\r\n  boq: [/bill of quantities/i, /boq/i, /schedule of quantities/i, /pricing schedule/i],\r\n  contract: [/contract/i, /agreement/i, /terms and conditions/i],\r\n  specification: [/specification/i, /technical requirements/i, /scope of work/i],\r\n  certificate: [/certificate/i, /certification/i, /clearance/i],\r\n  invoice: [/invoice/i, /tax invoice/i, /receipt/i],\r\n  form: [/form/i, /application/i, /declaration/i],\r\n}\r\n\r\n// Rate limits per tier\r\nexport const RATE_LIMITS = {\r\n  free: {\r\n    requests_per_minute: 10,\r\n    requests_per_day: 100,\r\n    max_pages_per_request: 50,\r\n  },\r\n  basic: {\r\n    requests_per_minute: 30,\r\n    requests_per_day: 500,\r\n    max_pages_per_request: 100,\r\n  },\r\n  professional: {\r\n    requests_per_minute: 60,\r\n    requests_per_day: 2000,\r\n    max_pages_per_request: 300,\r\n  },\r\n  enterprise: {\r\n    requests_per_minute: 200,\r\n    requests_per_day: 10000,\r\n    max_pages_per_request: 500,\r\n  },\r\n}\r\n\r\n// API version\r\nexport const API_VERSION = \"v1\"\r\n","// ============================================\r\n// DOCUMIND ENGINE - POSITION MAPPER\r\n// Handles coordinate system conversions\r\n// ============================================\r\n\r\nimport type { BoundingBox, NormalizedBox } from \"../types\"\r\n\r\n/**\r\n * PDF coordinate system: Origin at bottom-left, measured in points (72 pts = 1 inch)\r\n * Browser/Canvas coordinate system: Origin at top-left, measured in pixels\r\n * Normalized coordinate system: Origin at top-left, values 0-1 (percentage of page)\r\n */\r\n\r\nexport interface PageDimensions {\r\n  width: number\r\n  height: number\r\n}\r\n\r\n/**\r\n * Convert PDF coordinates to normalized (0-1) coordinates\r\n * PDF origin is bottom-left, normalized origin is top-left\r\n */\r\nexport function pdfToNormalized(box: BoundingBox, page: PageDimensions): NormalizedBox {\r\n  return {\r\n    x: box.x / page.width,\r\n    // Flip Y axis: PDF bottom-left to normalized top-left\r\n    y: 1 - (box.y + box.height) / page.height,\r\n    width: box.width / page.width,\r\n    height: box.height / page.height,\r\n  }\r\n}\r\n\r\n/**\r\n * Convert normalized coordinates back to PDF coordinates\r\n */\r\nexport function normalizedToPdf(box: NormalizedBox, page: PageDimensions): BoundingBox {\r\n  return {\r\n    x: box.x * page.width,\r\n    // Flip Y axis back: normalized top-left to PDF bottom-left\r\n    y: page.height - (box.y + box.height) * page.height,\r\n    width: box.width * page.width,\r\n    height: box.height * page.height,\r\n  }\r\n}\r\n\r\n/**\r\n * Convert PDF coordinates to pixel coordinates for canvas rendering\r\n */\r\nexport function pdfToPixel(box: BoundingBox, page: PageDimensions, scale = 1): BoundingBox {\r\n  return {\r\n    x: box.x * scale,\r\n    // Flip Y axis for canvas (top-left origin)\r\n    y: (page.height - box.y - box.height) * scale,\r\n    width: box.width * scale,\r\n    height: box.height * scale,\r\n  }\r\n}\r\n\r\n/**\r\n * Convert pixel coordinates (from canvas) to PDF coordinates\r\n */\r\nexport function pixelToPdf(box: BoundingBox, page: PageDimensions, scale = 1): BoundingBox {\r\n  return {\r\n    x: box.x / scale,\r\n    // Flip Y axis back to PDF\r\n    y: page.height - box.y / scale - box.height / scale,\r\n    width: box.width / scale,\r\n    height: box.height / scale,\r\n  }\r\n}\r\n\r\n/**\r\n * Convert normalized coordinates to pixel coordinates\r\n */\r\nexport function normalizedToPixel(box: NormalizedBox, page: PageDimensions, scale = 1): BoundingBox {\r\n  return {\r\n    x: box.x * page.width * scale,\r\n    y: box.y * page.height * scale,\r\n    width: box.width * page.width * scale,\r\n    height: box.height * page.height * scale,\r\n  }\r\n}\r\n\r\n/**\r\n * Convert pixel coordinates to normalized coordinates\r\n */\r\nexport function pixelToNormalized(box: BoundingBox, page: PageDimensions, scale = 1): NormalizedBox {\r\n  return {\r\n    x: box.x / scale / page.width,\r\n    y: box.y / scale / page.height,\r\n    width: box.width / scale / page.width,\r\n    height: box.height / scale / page.height,\r\n  }\r\n}\r\n\r\n/**\r\n * Check if two boxes overlap\r\n */\r\nexport function boxesOverlap(a: BoundingBox, b: BoundingBox): boolean {\r\n  return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)\r\n}\r\n\r\n/**\r\n * Check if box A contains box B\r\n */\r\nexport function boxContains(container: BoundingBox, inner: BoundingBox): boolean {\r\n  return (\r\n    inner.x >= container.x &&\r\n    inner.y >= container.y &&\r\n    inner.x + inner.width <= container.x + container.width &&\r\n    inner.y + inner.height <= container.y + container.height\r\n  )\r\n}\r\n\r\n/**\r\n * Calculate distance between two boxes (edge to edge)\r\n */\r\nexport function boxDistance(a: BoundingBox, b: BoundingBox): number {\r\n  const dx = Math.max(0, Math.max(a.x, b.x) - Math.min(a.x + a.width, b.x + b.width))\r\n  const dy = Math.max(0, Math.max(a.y, b.y) - Math.min(a.y + a.height, b.y + b.height))\r\n  return Math.sqrt(dx * dx + dy * dy)\r\n}\r\n\r\n/**\r\n * Get center point of a box\r\n */\r\nexport function boxCenter(box: BoundingBox): { x: number; y: number } {\r\n  return {\r\n    x: box.x + box.width / 2,\r\n    y: box.y + box.height / 2,\r\n  }\r\n}\r\n\r\n/**\r\n * Merge multiple boxes into one bounding box\r\n */\r\nexport function mergeBoxes(boxes: BoundingBox[]): BoundingBox {\r\n  if (boxes.length === 0) {\r\n    return { x: 0, y: 0, width: 0, height: 0 }\r\n  }\r\n\r\n  const minX = Math.min(...boxes.map((b) => b.x))\r\n  const minY = Math.min(...boxes.map((b) => b.y))\r\n  const maxX = Math.max(...boxes.map((b) => b.x + b.width))\r\n  const maxY = Math.max(...boxes.map((b) => b.y + b.height))\r\n\r\n  return {\r\n    x: minX,\r\n    y: minY,\r\n    width: maxX - minX,\r\n    height: maxY - minY,\r\n  }\r\n}\r\n\r\n/**\r\n * Expand a box by a given margin\r\n */\r\nexport function expandBox(box: BoundingBox, margin: number): BoundingBox {\r\n  return {\r\n    x: box.x - margin,\r\n    y: box.y - margin,\r\n    width: box.width + margin * 2,\r\n    height: box.height + margin * 2,\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a point is inside a box\r\n */\r\nexport function pointInBox(point: { x: number; y: number }, box: BoundingBox): boolean {\r\n  return point.x >= box.x && point.x <= box.x + box.width && point.y >= box.y && point.y <= box.y + box.height\r\n}\r\n\r\n/**\r\n * Calculate intersection over union (IoU) for two boxes\r\n * Used for comparing detected fields with template fields\r\n */\r\nexport function calculateIoU(a: BoundingBox, b: BoundingBox): number {\r\n  const intersectX = Math.max(a.x, b.x)\r\n  const intersectY = Math.max(a.y, b.y)\r\n  const intersectW = Math.min(a.x + a.width, b.x + b.width) - intersectX\r\n  const intersectH = Math.min(a.y + a.height, b.y + b.height) - intersectY\r\n\r\n  if (intersectW <= 0 || intersectH <= 0) {\r\n    return 0\r\n  }\r\n\r\n  const intersectionArea = intersectW * intersectH\r\n  const aArea = a.width * a.height\r\n  const bArea = b.width * b.height\r\n  const unionArea = aArea + bArea - intersectionArea\r\n\r\n  return intersectionArea / unionArea\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - PDF PARSER MODULE\r\n// Uses unpdf for text extraction (server-compatible)\r\n// Uses pdf-lib for form field extraction\r\n// ============================================\r\n\r\nimport type {\r\n  ParsedPage,\r\n  TextBlock,\r\n  FormField,\r\n  FormFieldType,\r\n  FormFieldOption,\r\n  FontInfo,\r\n  BoundingBox,\r\n  TextBlockType,\r\n  DocumentMetadata,\r\n  DocumentType,\r\n} from \"../types\"\r\nimport { pdfToNormalized } from \"../utils/position-mapper\"\r\nimport { DOCUMENT_TYPE_PATTERNS, OCR_CONFIG } from \"../constants\"\r\n\r\nlet PDFDocumentModule: typeof import(\"pdf-lib\").PDFDocument | null = null\r\n\r\nasync function getPdfLib() {\r\n  if (!PDFDocumentModule) {\r\n    const pdfLib = await import(\"pdf-lib\")\r\n    PDFDocumentModule = pdfLib.PDFDocument\r\n  }\r\n  return PDFDocumentModule\r\n}\r\n\r\nexport interface PDFParseResult {\r\n  metadata: DocumentMetadata\r\n  pages: ParsedPage[]\r\n  formFields: FormField[]\r\n  rawText: string\r\n  isScanned: boolean\r\n}\r\n\r\nexport interface PDFParseOptions {\r\n  extractImages?: boolean\r\n  maxPages?: number\r\n  password?: string\r\n}\r\n\r\n/**\r\n * Main PDF parsing function\r\n * Now uses unpdf for server-compatible text extraction\r\n */\r\nexport async function parsePDF(data: ArrayBuffer | Uint8Array, options: PDFParseOptions = {}): Promise<PDFParseResult> {\r\n  const { maxPages } = options\r\n\r\n  let uint8Data: Uint8Array\r\n  if (data instanceof ArrayBuffer) {\r\n    uint8Data = new Uint8Array(data)\r\n  } else if (data instanceof Uint8Array) {\r\n    uint8Data = data\r\n  } else {\r\n    // Handle Buffer or other array-like objects\r\n    uint8Data = new Uint8Array(data as ArrayBufferLike)\r\n  }\r\n\r\n  const header = String.fromCharCode(...uint8Data.slice(0, 8))\r\n  console.log(\"[v0] PDF header check:\", header.substring(0, 5), \"Length:\", uint8Data.length)\r\n\r\n  if (!header.startsWith(\"%PDF-\")) {\r\n    throw new Error(`Invalid PDF: Expected %PDF- header but got: ${header.substring(0, 10)}`)\r\n  }\r\n\r\n  const PDFDocument = await getPdfLib()\r\n  const pdfDoc = await PDFDocument.load(uint8Data, { ignoreEncryption: true })\r\n  const pageCount = pdfDoc.getPageCount()\r\n\r\n  console.log(\"[v0] PDF loaded with pdf-lib, pages:\", pageCount)\r\n\r\n  // Determine page range\r\n  const pagesToProcess = maxPages ? Math.min(pageCount, maxPages) : pageCount\r\n\r\n  let fullText = \"\"\r\n  let pageTexts: string[] = []\r\n\r\n  try {\r\n    const { getDocumentProxy, extractText } = await import(\"unpdf\")\r\n\r\n    // Create a copy of the data for unpdf\r\n    const pdfData = uint8Data.slice()\r\n    const pdf = await getDocumentProxy(pdfData)\r\n\r\n    const mergedResult = await extractText(pdf, { mergePages: true })\r\n    fullText = typeof mergedResult.text === \"string\" ? mergedResult.text : (mergedResult.text as string[]).join(\"\\n\\n\")\r\n\r\n    const perPageResult = await extractText(pdf, { mergePages: false })\r\n    pageTexts = Array.isArray(perPageResult.text) ? perPageResult.text : [perPageResult.text as string]\r\n\r\n    console.log(\"[v0] Text extracted via unpdf, length:\", fullText.length)\r\n  } catch (unpdfError) {\r\n    console.log(\"[v0] unpdf extraction failed, using basic extraction:\", unpdfError)\r\n    // Fallback: just use empty text - documents will be marked as scanned\r\n    pageTexts = new Array(pagesToProcess).fill(\"\")\r\n    fullText = \"\"\r\n  }\r\n\r\n  // Build pages\r\n  const pages: ParsedPage[] = []\r\n  let totalTextLength = 0\r\n\r\n  for (let i = 0; i < pagesToProcess; i++) {\r\n    const pageText = pageTexts[i] || \"\"\r\n    const page = pdfDoc.getPage(i)\r\n    const { width, height } = page.getSize()\r\n\r\n    const parsedPage = createParsedPage(pageText, i + 1, width, height)\r\n    pages.push(parsedPage)\r\n    totalTextLength += pageText.length\r\n  }\r\n\r\n  // Detect if document is scanned (low text density)\r\n  const avgTextPerPage = totalTextLength / pagesToProcess\r\n  const isScanned = avgTextPerPage < OCR_CONFIG.min_text_density * 1000\r\n\r\n  // Extract form fields using pdf-lib\r\n  const formFields = await extractFormFields(uint8Data)\r\n\r\n  // Extract metadata using pdf-lib\r\n  const metadata = await extractMetadataFromPdfLib(pdfDoc, pageCount, isScanned, fullText)\r\n\r\n  return {\r\n    metadata,\r\n    pages,\r\n    formFields,\r\n    rawText: fullText,\r\n    isScanned,\r\n  }\r\n}\r\n\r\n/**\r\n * Create a parsed page from text content\r\n * Simplified page creation without pdfjs position data\r\n */\r\nfunction createParsedPage(pageText: string, pageNumber: number, width: number, height: number): ParsedPage {\r\n  const textBlocks = createTextBlocks(pageText, pageNumber, width, height)\r\n  const isScanned = pageText.length < OCR_CONFIG.min_text_density * 1000\r\n\r\n  return {\r\n    page_number: pageNumber,\r\n    width,\r\n    height,\r\n    rotation: 0,\r\n    content: {\r\n      full_text: pageText,\r\n      text_blocks: textBlocks,\r\n      lines: [], // Line detection requires visual analysis - will be enhanced later\r\n      rectangles: [], // Rectangle detection requires visual analysis\r\n      images: [],\r\n    },\r\n    is_scanned: isScanned,\r\n    ocr_confidence: null,\r\n  }\r\n}\r\n\r\n/**\r\n * Create text blocks from page text\r\n * Creates logical text blocks from extracted text\r\n */\r\nfunction createTextBlocks(pageText: string, pageNumber: number, pageWidth: number, pageHeight: number): TextBlock[] {\r\n  const blocks: TextBlock[] = []\r\n  const lines = pageText.split(\"\\n\").filter((line) => line.trim())\r\n\r\n  let yPosition = pageHeight - 50 // Start from top\r\n  const lineHeight = 14\r\n\r\n  lines.forEach((line, index) => {\r\n    const trimmedLine = line.trim()\r\n    if (!trimmedLine) return\r\n\r\n    // Estimate position based on line index\r\n    const position: BoundingBox = {\r\n      x: 50,\r\n      y: yPosition,\r\n      width: Math.min(trimmedLine.length * 7, pageWidth - 100),\r\n      height: lineHeight,\r\n    }\r\n\r\n    // Classify the block type\r\n    const blockType = classifyTextBlockFromContent(trimmedLine)\r\n    const font = estimateFontFromBlockType(blockType)\r\n\r\n    blocks.push({\r\n      id: `tb-${pageNumber}-${index}`,\r\n      text: trimmedLine,\r\n      position,\r\n      position_normalized: pdfToNormalized(position, { width: pageWidth, height: pageHeight }),\r\n      font,\r\n      block_type: blockType,\r\n      line_index: index,\r\n      paragraph_index: Math.floor(index / 5),\r\n      confidence: 0.8, // Estimated confidence\r\n      words: null,\r\n    })\r\n\r\n    yPosition -= lineHeight * 1.5\r\n  })\r\n\r\n  return blocks\r\n}\r\n\r\n/**\r\n * Classify text block type from content\r\n */\r\nfunction classifyTextBlockFromContent(text: string): TextBlockType {\r\n  const trimmed = text.trim()\r\n\r\n  // Check for headings (all caps, short, or numbered sections)\r\n  if (trimmed === trimmed.toUpperCase() && trimmed.length < 100 && trimmed.length > 2) {\r\n    return \"heading_1\"\r\n  }\r\n\r\n  // Check for section numbers like \"1.\", \"1.1\", \"Section 1\"\r\n  if (/^(\\d+\\.?\\d*\\.?\\d*|\\w+\\s+\\d+)[.:]\\s/.test(trimmed)) {\r\n    if (trimmed.length < 80) return \"heading_2\"\r\n  }\r\n\r\n  // Check for labels (ends with colon)\r\n  if (trimmed.endsWith(\":\") && trimmed.length < 50) {\r\n    return \"label\"\r\n  }\r\n\r\n  // Check for list items\r\n  if (/^[\\u2022\\u2023\\u25E6\\u2043\\u2219â€¢\\-*]\\s/.test(trimmed)) {\r\n    return \"list_item\"\r\n  }\r\n  if (/^\\d+[.)]\\s/.test(trimmed)) {\r\n    return \"list_item\"\r\n  }\r\n\r\n  // Check for page numbers\r\n  if (/^(Page\\s*)?\\d+(\\s*of\\s*\\d+)?$/i.test(trimmed)) {\r\n    return \"page_number\"\r\n  }\r\n\r\n  return \"paragraph\"\r\n}\r\n\r\n/**\r\n * Estimate font info from block type\r\n */\r\nfunction estimateFontFromBlockType(blockType: TextBlockType): FontInfo {\r\n  const baseFontSize = 12\r\n\r\n  switch (blockType) {\r\n    case \"heading_1\":\r\n      return {\r\n        name: \"Helvetica-Bold\",\r\n        family: \"Helvetica\",\r\n        size: 18,\r\n        weight: \"bold\",\r\n        style: \"normal\",\r\n        color: \"#000000\",\r\n      }\r\n    case \"heading_2\":\r\n      return {\r\n        name: \"Helvetica-Bold\",\r\n        family: \"Helvetica\",\r\n        size: 14,\r\n        weight: \"bold\",\r\n        style: \"normal\",\r\n        color: \"#000000\",\r\n      }\r\n    case \"heading_3\":\r\n      return {\r\n        name: \"Helvetica-Bold\",\r\n        family: \"Helvetica\",\r\n        size: 12,\r\n        weight: \"bold\",\r\n        style: \"normal\",\r\n        color: \"#000000\",\r\n      }\r\n    case \"label\":\r\n      return {\r\n        name: \"Helvetica-Bold\",\r\n        family: \"Helvetica\",\r\n        size: 11,\r\n        weight: \"bold\",\r\n        style: \"normal\",\r\n        color: \"#000000\",\r\n      }\r\n    default:\r\n      return {\r\n        name: \"Helvetica\",\r\n        family: \"Helvetica\",\r\n        size: baseFontSize,\r\n        weight: \"normal\",\r\n        style: \"normal\",\r\n        color: \"#000000\",\r\n      }\r\n  }\r\n}\r\n\r\n/**\r\n * Extract metadata using pdf-lib\r\n * Now accepts pre-loaded pdfDoc instead of raw data\r\n */\r\nasync function extractMetadataFromPdfLib(\r\n  pdfDoc: import(\"pdf-lib\").PDFDocument,\r\n  pageCount: number,\r\n  isScanned: boolean,\r\n  fullText: string,\r\n): Promise<DocumentMetadata> {\r\n  try {\r\n    return {\r\n      title: pdfDoc.getTitle() || null,\r\n      author: pdfDoc.getAuthor() || null,\r\n      subject: pdfDoc.getSubject() || null,\r\n      creator: pdfDoc.getCreator() || null,\r\n      producer: pdfDoc.getProducer() || null,\r\n      creation_date: pdfDoc.getCreationDate()?.toISOString() || null,\r\n      modification_date: pdfDoc.getModificationDate()?.toISOString() || null,\r\n      page_count: pageCount,\r\n      pdf_version: null,\r\n      is_encrypted: false,\r\n      is_scanned: isScanned,\r\n      detected_language: \"en\",\r\n      detected_type: detectDocumentType(fullText),\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error extracting metadata:\", error)\r\n    return {\r\n      title: null,\r\n      author: null,\r\n      subject: null,\r\n      creator: null,\r\n      producer: null,\r\n      creation_date: null,\r\n      modification_date: null,\r\n      page_count: pageCount,\r\n      pdf_version: null,\r\n      is_encrypted: false,\r\n      is_scanned: isScanned,\r\n      detected_language: \"en\",\r\n      detected_type: detectDocumentType(fullText),\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Extract form fields using pdf-lib\r\n */\r\nasync function extractFormFields(data: Uint8Array): Promise<FormField[]> {\r\n  try {\r\n    const PDFDocument = await getPdfLib()\r\n    const pdfDoc = await PDFDocument.load(data, { ignoreEncryption: true })\r\n    const form = pdfDoc.getForm()\r\n    const fields = form.getFields()\r\n    const formFields: FormField[] = []\r\n\r\n    for (const field of fields) {\r\n      const widgets = field.acroField.getWidgets()\r\n      if (widgets.length === 0) continue\r\n\r\n      const widget = widgets[0]\r\n      const rect = widget.getRectangle()\r\n      const page = pdfDoc.getPages().findIndex((p: any) => {\r\n        const pageRef = p.ref\r\n        const widgetPage = widget.P()\r\n        return widgetPage && pageRef.toString() === widgetPage.toString()\r\n      })\r\n\r\n      const pageObj = pdfDoc.getPage(Math.max(0, page))\r\n      const { width: pageWidth, height: pageHeight } = pageObj.getSize()\r\n\r\n      const position: BoundingBox = {\r\n        x: rect.x,\r\n        y: rect.y,\r\n        width: rect.width,\r\n        height: rect.height,\r\n      }\r\n\r\n      const fieldType = getFieldType(field)\r\n      const fieldValue = getFieldValue(field, fieldType)\r\n      const options = getFieldOptions(field, fieldType)\r\n\r\n      formFields.push({\r\n        id: field.getName(),\r\n        name: field.getName(),\r\n        type: fieldType,\r\n        page: Math.max(1, page + 1),\r\n        position,\r\n        position_normalized: pdfToNormalized(position, {\r\n          width: pageWidth,\r\n          height: pageHeight,\r\n        }),\r\n        value: fieldValue,\r\n        default_value: null,\r\n        is_required: field.isRequired(),\r\n        is_readonly: field.isReadOnly(),\r\n        max_length: null,\r\n        options,\r\n        font: null,\r\n        text_alignment: \"left\",\r\n        format: null,\r\n      })\r\n    }\r\n\r\n    return formFields\r\n  } catch (error) {\r\n    console.error(\"Error extracting form fields:\", error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Determine field type from pdf-lib field\r\n */\r\nfunction getFieldType(field: any): FormFieldType {\r\n  const constructor = field.constructor.name\r\n\r\n  switch (constructor) {\r\n    case \"PDFTextField\":\r\n      return \"text\"\r\n    case \"PDFCheckBox\":\r\n      return \"checkbox\"\r\n    case \"PDFRadioGroup\":\r\n      return \"radio\"\r\n    case \"PDFDropdown\":\r\n      return \"select\"\r\n    case \"PDFSignature\":\r\n      return \"signature\"\r\n    case \"PDFButton\":\r\n      return \"button\"\r\n    default:\r\n      return \"text\"\r\n  }\r\n}\r\n\r\n/**\r\n * Get field value based on type\r\n */\r\nfunction getFieldValue(field: any, type: FormFieldType): string | boolean | string[] | null {\r\n  try {\r\n    switch (type) {\r\n      case \"checkbox\":\r\n        return field.isChecked()\r\n      case \"radio\":\r\n        return field.getSelected() || null\r\n      case \"select\":\r\n        return field.getSelected() || []\r\n      case \"text\":\r\n        return field.getText() || null\r\n      default:\r\n        return null\r\n    }\r\n  } catch {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Get field options for select/radio\r\n */\r\nfunction getFieldOptions(field: any, type: FormFieldType): FormFieldOption[] {\r\n  if (type !== \"select\" && type !== \"radio\") return []\r\n\r\n  try {\r\n    const options = field.getOptions?.() || []\r\n    return options.map((opt: string, idx: number) => ({\r\n      value: opt,\r\n      label: opt,\r\n      is_default: idx === 0,\r\n    }))\r\n  } catch {\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Detect document type from content\r\n */\r\nfunction detectDocumentType(text: string): DocumentType {\r\n  const lowerText = text.toLowerCase()\r\n\r\n  for (const [type, patterns] of Object.entries(DOCUMENT_TYPE_PATTERNS)) {\r\n    for (const pattern of patterns) {\r\n      if (pattern.test(lowerText)) {\r\n        return type as DocumentType\r\n      }\r\n    }\r\n  }\r\n\r\n  return \"unknown\"\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - LAYOUT ANALYZER MODULE\r\n// Analyzes document structure and detects regions\r\n// ============================================\r\n\r\nimport type {\r\n  ParsedPage,\r\n  TextBlock,\r\n  LineElement,\r\n  RectElement,\r\n  DocumentLayout,\r\n  DocumentSection,\r\n  TableRegion,\r\n  FormRegion,\r\n  DetectedField,\r\n  DocumentType,\r\n  InputType,\r\n  DetectionMethod,\r\n  FieldDataType,\r\n  BoundingBox,\r\n} from \"../types\"\r\nimport { boxDistance, boxesOverlap, mergeBoxes, pdfToNormalized } from \"../utils/position-mapper\"\r\nimport { FIELD_DETECTION } from \"../constants\"\r\n\r\nexport interface LayoutAnalysisResult {\r\n  layout: DocumentLayout\r\n  detectedFields: DetectedField[]\r\n  tableRegions: TableRegion[]\r\n}\r\n\r\n/**\r\n * Main layout analysis function\r\n */\r\nexport function analyzeLayout(pages: ParsedPage[], documentType: DocumentType): LayoutAnalysisResult {\r\n  // Extract sections from headings\r\n  const sections = extractSections(pages)\r\n\r\n  // Find title\r\n  const title = findDocumentTitle(pages)\r\n\r\n  // Detect table regions\r\n  const tableRegions = detectTableRegions(pages)\r\n\r\n  // Detect form regions and fields\r\n  const { formRegions, detectedFields } = detectFormRegions(pages)\r\n\r\n  // Build reading order\r\n  const readingOrder = buildReadingOrder(pages)\r\n\r\n  return {\r\n    layout: {\r\n      document_type: documentType,\r\n      title,\r\n      sections,\r\n      table_regions: tableRegions,\r\n      form_regions: formRegions,\r\n      reading_order: readingOrder,\r\n    },\r\n    detectedFields,\r\n    tableRegions,\r\n  }\r\n}\r\n\r\n/**\r\n * Extract document sections from headings\r\n */\r\nfunction extractSections(pages: ParsedPage[]): DocumentSection[] {\r\n  const sections: DocumentSection[] = []\r\n  let currentSection: DocumentSection | null = null\r\n  let sectionId = 0\r\n\r\n  pages.forEach((page) => {\r\n    page.content.text_blocks.forEach((block) => {\r\n      if (block.block_type.startsWith(\"heading\")) {\r\n        const level = Number.parseInt(block.block_type.split(\"_\")[1]) || 1\r\n\r\n        const newSection: DocumentSection = {\r\n          id: `section-${sectionId++}`,\r\n          title: block.text,\r\n          level,\r\n          page_start: page.page_number,\r\n          page_end: page.page_number,\r\n          block_ids: [block.id],\r\n          subsections: [],\r\n        }\r\n\r\n        if (level === 1) {\r\n          // Top-level section\r\n          if (currentSection) {\r\n            sections.push(currentSection)\r\n          }\r\n          currentSection = newSection\r\n        } else if (currentSection) {\r\n          // Subsection\r\n          if (level === 2) {\r\n            currentSection.subsections.push(newSection)\r\n          } else if (level === 3 && currentSection.subsections.length > 0) {\r\n            const lastSubsection = currentSection.subsections[currentSection.subsections.length - 1]\r\n            lastSubsection.subsections.push(newSection)\r\n          }\r\n        } else {\r\n          currentSection = newSection\r\n        }\r\n      } else if (currentSection) {\r\n        // Add content blocks to current section\r\n        currentSection.block_ids.push(block.id)\r\n        currentSection.page_end = page.page_number\r\n      }\r\n    })\r\n  })\r\n\r\n  if (currentSection) {\r\n    sections.push(currentSection)\r\n  }\r\n\r\n  return sections\r\n}\r\n\r\n/**\r\n * Find document title (first prominent heading or first large text)\r\n */\r\nfunction findDocumentTitle(pages: ParsedPage[]): TextBlock | null {\r\n  if (pages.length === 0) return null\r\n\r\n  const firstPage = pages[0]\r\n\r\n  // Look for heading_1\r\n  const h1 = firstPage.content.text_blocks.find((b) => b.block_type === \"heading_1\")\r\n  if (h1) return h1\r\n\r\n  // Look for largest text in top half of page\r\n  const topHalfBlocks = firstPage.content.text_blocks.filter((b) => b.position_normalized.y < 0.5)\r\n\r\n  if (topHalfBlocks.length === 0) return null\r\n\r\n  return topHalfBlocks.reduce((largest, block) => (block.font.size > largest.font.size ? block : largest))\r\n}\r\n\r\n/**\r\n * Detect table regions\r\n */\r\nfunction detectTableRegions(pages: ParsedPage[]): TableRegion[] {\r\n  const tableRegions: TableRegion[] = []\r\n  let tableId = 0\r\n\r\n  pages.forEach((page) => {\r\n    const pageDimensions = { width: page.width, height: page.height }\r\n\r\n    // Method 1: Find grid patterns from lines\r\n    const gridRegions = findGridPatterns(page.content.lines, pageDimensions)\r\n\r\n    // Method 2: Find aligned text patterns (columns of data)\r\n    const textTableRegions = findTextTablePatterns(page.content.text_blocks, pageDimensions)\r\n\r\n    // Merge detected regions\r\n    const mergedRegions = mergeOverlappingRegions([...gridRegions, ...textTableRegions])\r\n\r\n    mergedRegions.forEach((region) => {\r\n      tableRegions.push({\r\n        id: `table-${tableId++}`,\r\n        page: page.page_number,\r\n        position: region.position,\r\n        position_normalized: pdfToNormalized(region.position, pageDimensions),\r\n        row_count_estimate: region.rows,\r\n        column_count_estimate: region.cols,\r\n        has_header: region.hasHeader,\r\n        extraction_status: \"pending\",\r\n        table_data: null,\r\n      })\r\n    })\r\n  })\r\n\r\n  return tableRegions\r\n}\r\n\r\n/**\r\n * Find grid patterns from horizontal and vertical lines\r\n */\r\nfunction findGridPatterns(\r\n  lines: LineElement[],\r\n  pageDimensions: { width: number; height: number },\r\n): Array<{\r\n  position: BoundingBox\r\n  rows: number\r\n  cols: number\r\n  hasHeader: boolean\r\n}> {\r\n  const horizontalLines = lines.filter((l) => l.type === \"horizontal\")\r\n  const verticalLines = lines.filter((l) => l.type === \"vertical\")\r\n\r\n  if (horizontalLines.length < 2 || verticalLines.length < 2) {\r\n    return []\r\n  }\r\n\r\n  // Group lines by proximity\r\n  const hGroups = groupLinesByPosition(horizontalLines, \"y\")\r\n  const vGroups = groupLinesByPosition(verticalLines, \"x\")\r\n\r\n  const grids: Array<{\r\n    position: BoundingBox\r\n    rows: number\r\n    cols: number\r\n    hasHeader: boolean\r\n  }> = []\r\n\r\n  // Find intersecting line groups that form grids\r\n  if (hGroups.length >= 2 && vGroups.length >= 2) {\r\n    const minX = Math.min(...verticalLines.map((l) => l.start.x))\r\n    const maxX = Math.max(...verticalLines.map((l) => l.start.x))\r\n    const minY = Math.min(...horizontalLines.map((l) => l.start.y))\r\n    const maxY = Math.max(...horizontalLines.map((l) => l.start.y))\r\n\r\n    grids.push({\r\n      position: {\r\n        x: minX,\r\n        y: minY,\r\n        width: maxX - minX,\r\n        height: maxY - minY,\r\n      },\r\n      rows: hGroups.length - 1,\r\n      cols: vGroups.length - 1,\r\n      hasHeader: true, // Assume first row is header\r\n    })\r\n  }\r\n\r\n  return grids\r\n}\r\n\r\n/**\r\n * Group lines by their position\r\n */\r\nfunction groupLinesByPosition(lines: LineElement[], axis: \"x\" | \"y\"): number[][] {\r\n  const tolerance = 5\r\n  const positions = lines.map((l) => l.start[axis])\r\n  const groups: number[][] = []\r\n\r\n  positions.sort((a, b) => a - b)\r\n\r\n  let currentGroup: number[] = []\r\n  let lastPos = Number.NEGATIVE_INFINITY\r\n\r\n  positions.forEach((pos) => {\r\n    if (pos - lastPos > tolerance) {\r\n      if (currentGroup.length > 0) {\r\n        groups.push(currentGroup)\r\n      }\r\n      currentGroup = [pos]\r\n    } else {\r\n      currentGroup.push(pos)\r\n    }\r\n    lastPos = pos\r\n  })\r\n\r\n  if (currentGroup.length > 0) {\r\n    groups.push(currentGroup)\r\n  }\r\n\r\n  return groups\r\n}\r\n\r\n/**\r\n * Find table patterns from aligned text blocks\r\n */\r\nfunction findTextTablePatterns(\r\n  blocks: TextBlock[],\r\n  pageDimensions: { width: number; height: number },\r\n): Array<{\r\n  position: BoundingBox\r\n  rows: number\r\n  cols: number\r\n  hasHeader: boolean\r\n}> {\r\n  // Group blocks by similar Y positions (rows)\r\n  const rowGroups = groupBlocksByRow(blocks)\r\n\r\n  // Find sequences of rows with similar column structure\r\n  const tables: Array<{\r\n    position: BoundingBox\r\n    rows: number\r\n    cols: number\r\n    hasHeader: boolean\r\n  }> = []\r\n\r\n  let tableStart = -1\r\n  let lastColCount = 0\r\n  let tableBlocks: TextBlock[] = []\r\n\r\n  rowGroups.forEach((row, idx) => {\r\n    const colCount = estimateColumnCount(row)\r\n\r\n    if (colCount >= 2) {\r\n      if (tableStart === -1) {\r\n        tableStart = idx\r\n        lastColCount = colCount\r\n        tableBlocks = [...row]\r\n      } else if (Math.abs(colCount - lastColCount) <= 1) {\r\n        tableBlocks.push(...row)\r\n      } else {\r\n        // End current table, start new\r\n        if (tableBlocks.length >= 4) {\r\n          tables.push(createTableFromBlocks(tableBlocks, lastColCount))\r\n        }\r\n        tableStart = idx\r\n        lastColCount = colCount\r\n        tableBlocks = [...row]\r\n      }\r\n    } else {\r\n      if (tableBlocks.length >= 4) {\r\n        tables.push(createTableFromBlocks(tableBlocks, lastColCount))\r\n      }\r\n      tableStart = -1\r\n      tableBlocks = []\r\n    }\r\n  })\r\n\r\n  if (tableBlocks.length >= 4) {\r\n    tables.push(createTableFromBlocks(tableBlocks, lastColCount))\r\n  }\r\n\r\n  return tables\r\n}\r\n\r\n/**\r\n * Group text blocks by row (similar Y position)\r\n */\r\nfunction groupBlocksByRow(blocks: TextBlock[]): TextBlock[][] {\r\n  const tolerance = 10\r\n  const sorted = [...blocks].sort((a, b) => b.position.y - a.position.y) // Top to bottom in PDF coords\r\n\r\n  const rows: TextBlock[][] = []\r\n  let currentRow: TextBlock[] = []\r\n  let lastY = Number.POSITIVE_INFINITY\r\n\r\n  sorted.forEach((block) => {\r\n    if (Math.abs(block.position.y - lastY) > tolerance) {\r\n      if (currentRow.length > 0) {\r\n        rows.push(currentRow.sort((a, b) => a.position.x - b.position.x))\r\n      }\r\n      currentRow = [block]\r\n    } else {\r\n      currentRow.push(block)\r\n    }\r\n    lastY = block.position.y\r\n  })\r\n\r\n  if (currentRow.length > 0) {\r\n    rows.push(currentRow.sort((a, b) => a.position.x - b.position.x))\r\n  }\r\n\r\n  return rows\r\n}\r\n\r\n/**\r\n * Estimate column count from a row of blocks\r\n */\r\nfunction estimateColumnCount(row: TextBlock[]): number {\r\n  if (row.length <= 1) return row.length\r\n\r\n  // Count significant gaps between blocks\r\n  const gaps: number[] = []\r\n  for (let i = 1; i < row.length; i++) {\r\n    const gap = row[i].position.x - (row[i - 1].position.x + row[i - 1].position.width)\r\n    gaps.push(gap)\r\n  }\r\n\r\n  // Average gap\r\n  const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length\r\n\r\n  // Count gaps larger than average (column separators)\r\n  const significantGaps = gaps.filter((g) => g > avgGap * 1.5).length\r\n\r\n  return significantGaps + 1\r\n}\r\n\r\n/**\r\n * Create table region from blocks\r\n */\r\nfunction createTableFromBlocks(\r\n  blocks: TextBlock[],\r\n  cols: number,\r\n): {\r\n  position: BoundingBox\r\n  rows: number\r\n  cols: number\r\n  hasHeader: boolean\r\n} {\r\n  const position = mergeBoxes(blocks.map((b) => b.position))\r\n  const rowGroups = groupBlocksByRow(blocks)\r\n\r\n  return {\r\n    position,\r\n    rows: rowGroups.length,\r\n    cols,\r\n    hasHeader: true,\r\n  }\r\n}\r\n\r\n/**\r\n * Merge overlapping regions\r\n */\r\nfunction mergeOverlappingRegions(\r\n  regions: Array<{\r\n    position: BoundingBox\r\n    rows: number\r\n    cols: number\r\n    hasHeader: boolean\r\n  }>,\r\n): Array<{\r\n  position: BoundingBox\r\n  rows: number\r\n  cols: number\r\n  hasHeader: boolean\r\n}> {\r\n  if (regions.length <= 1) return regions\r\n\r\n  const merged: typeof regions = []\r\n\r\n  regions.forEach((region) => {\r\n    const overlapping = merged.findIndex((m) => boxesOverlap(m.position, region.position))\r\n\r\n    if (overlapping >= 0) {\r\n      // Merge with existing\r\n      merged[overlapping] = {\r\n        position: mergeBoxes([merged[overlapping].position, region.position]),\r\n        rows: Math.max(merged[overlapping].rows, region.rows),\r\n        cols: Math.max(merged[overlapping].cols, region.cols),\r\n        hasHeader: merged[overlapping].hasHeader || region.hasHeader,\r\n      }\r\n    } else {\r\n      merged.push(region)\r\n    }\r\n  })\r\n\r\n  return merged\r\n}\r\n\r\n/**\r\n * Detect form regions and fields\r\n */\r\nfunction detectFormRegions(pages: ParsedPage[]): {\r\n  formRegions: FormRegion[]\r\n  detectedFields: DetectedField[]\r\n} {\r\n  const formRegions: FormRegion[] = []\r\n  const detectedFields: DetectedField[] = []\r\n  let regionId = 0\r\n  let fieldId = 0\r\n\r\n  pages.forEach((page) => {\r\n    const pageDimensions = { width: page.width, height: page.height }\r\n\r\n    // Find labels (text ending with colon)\r\n    const labels = page.content.text_blocks.filter((b) => b.block_type === \"label\" || b.text.trim().endsWith(\":\"))\r\n\r\n    // Find form lines (horizontal lines that could be underlines)\r\n    const formLines = page.content.lines.filter((l) => l.is_form_line)\r\n\r\n    // Find text boxes (rectangles)\r\n    const textBoxes = page.content.rectangles.filter((r) => r.rect_type === \"text_box\")\r\n\r\n    // Find checkboxes\r\n    const checkboxes = page.content.rectangles.filter((r) => r.rect_type === \"checkbox\")\r\n\r\n    // Match labels to input areas\r\n    const pageFields: DetectedField[] = []\r\n\r\n    labels.forEach((label) => {\r\n      // Look for line to the right or below\r\n      const nearbyLine = findNearbyInputLine(label, formLines)\r\n      const nearbyBox = findNearbyInputBox(label, textBoxes)\r\n      const nearbyCheckbox = findNearbyCheckbox(label, checkboxes)\r\n\r\n      if (nearbyLine) {\r\n        pageFields.push(\r\n          createDetectedField(\r\n            `field-${fieldId++}`,\r\n            label,\r\n            {\r\n              type: \"text_line\",\r\n              position: lineToBox(nearbyLine),\r\n            },\r\n            pageDimensions,\r\n            \"line_detection\",\r\n          ),\r\n        )\r\n      } else if (nearbyBox) {\r\n        pageFields.push(\r\n          createDetectedField(\r\n            `field-${fieldId++}`,\r\n            label,\r\n            {\r\n              type: \"text_box\",\r\n              position: nearbyBox.position,\r\n            },\r\n            pageDimensions,\r\n            \"box_detection\",\r\n          ),\r\n        )\r\n      } else if (nearbyCheckbox) {\r\n        pageFields.push(\r\n          createDetectedField(\r\n            `field-${fieldId++}`,\r\n            label,\r\n            {\r\n              type: \"checkbox\",\r\n              position: nearbyCheckbox.position,\r\n            },\r\n            pageDimensions,\r\n            \"box_detection\",\r\n          ),\r\n        )\r\n      } else {\r\n        // Look for pattern-based detection (Label: _____)\r\n        const patternInput = detectPatternInput(label, page.content.text_blocks)\r\n        if (patternInput) {\r\n          pageFields.push(\r\n            createDetectedField(`field-${fieldId++}`, label, patternInput, pageDimensions, \"pattern_matching\"),\r\n          )\r\n        }\r\n      }\r\n    })\r\n\r\n    if (pageFields.length > 0) {\r\n      // Create form region encompassing all fields\r\n      const allPositions = pageFields.flatMap((f) => [f.label.position, f.input.position])\r\n      const regionPosition = mergeBoxes(allPositions)\r\n\r\n      formRegions.push({\r\n        id: `form-region-${regionId++}`,\r\n        page: page.page_number,\r\n        position: regionPosition,\r\n        position_normalized: pdfToNormalized(regionPosition, pageDimensions),\r\n        detected_fields: pageFields,\r\n      })\r\n\r\n      detectedFields.push(...pageFields)\r\n    }\r\n  })\r\n\r\n  return { formRegions, detectedFields }\r\n}\r\n\r\n/**\r\n * Find nearby input line for a label\r\n */\r\nfunction findNearbyInputLine(label: TextBlock, lines: LineElement[]): LineElement | null {\r\n  const maxDistance = FIELD_DETECTION.max_label_distance\r\n\r\n  // Look for line to the right (same line) or below\r\n  const candidates = lines.filter((line) => {\r\n    // Line should be to the right or below the label\r\n    const labelRight = label.position.x + label.position.width\r\n    const labelBottom = label.position.y\r\n\r\n    // Right of label\r\n    if (\r\n      line.start.x >= labelRight - 10 &&\r\n      line.start.x <= labelRight + maxDistance &&\r\n      Math.abs(line.start.y - label.position.y) < label.position.height\r\n    ) {\r\n      return true\r\n    }\r\n\r\n    // Below label\r\n    if (\r\n      line.start.y <= labelBottom &&\r\n      line.start.y >= labelBottom - maxDistance &&\r\n      Math.abs(line.start.x - label.position.x) < maxDistance\r\n    ) {\r\n      return true\r\n    }\r\n\r\n    return false\r\n  })\r\n\r\n  if (candidates.length === 0) return null\r\n\r\n  // Return closest\r\n  return candidates.reduce((closest, line) => {\r\n    const closestDist = boxDistance(label.position, lineToBox(closest))\r\n    const lineDist = boxDistance(label.position, lineToBox(line))\r\n    return lineDist < closestDist ? line : closest\r\n  })\r\n}\r\n\r\n/**\r\n * Find nearby input box for a label\r\n */\r\nfunction findNearbyInputBox(label: TextBlock, boxes: RectElement[]): RectElement | null {\r\n  const maxDistance = FIELD_DETECTION.max_label_distance\r\n\r\n  const candidates = boxes.filter((box) => {\r\n    const dist = boxDistance(label.position, box.position)\r\n    return dist < maxDistance\r\n  })\r\n\r\n  if (candidates.length === 0) return null\r\n\r\n  return candidates.reduce((closest, box) => {\r\n    const closestDist = boxDistance(label.position, closest.position)\r\n    const boxDist = boxDistance(label.position, box.position)\r\n    return boxDist < closestDist ? box : closest\r\n  })\r\n}\r\n\r\n/**\r\n * Find nearby checkbox for a label\r\n */\r\nfunction findNearbyCheckbox(label: TextBlock, checkboxes: RectElement[]): RectElement | null {\r\n  const maxDistance = FIELD_DETECTION.max_label_distance * 2 // Checkboxes can be further\r\n\r\n  const candidates = checkboxes.filter((cb) => {\r\n    const dist = boxDistance(label.position, cb.position)\r\n    return dist < maxDistance\r\n  })\r\n\r\n  if (candidates.length === 0) return null\r\n\r\n  return candidates.reduce((closest, cb) => {\r\n    const closestDist = boxDistance(label.position, closest.position)\r\n    const cbDist = boxDistance(label.position, cb.position)\r\n    return cbDist < closestDist ? cb : closest\r\n  })\r\n}\r\n\r\n/**\r\n * Detect input from text patterns (Label: _____)\r\n */\r\nfunction detectPatternInput(label: TextBlock, blocks: TextBlock[]): { type: InputType; position: BoundingBox } | null {\r\n  // Look for underscores or blank space after label\r\n  const labelText = label.text.trim()\r\n\r\n  // Check if there's a block with underscores nearby\r\n  const underscoreBlock = blocks.find((b) => {\r\n    if (b.id === label.id) return false\r\n    if (b.position.y !== label.position.y) return false\r\n\r\n    const afterLabel = b.position.x > label.position.x + label.position.width\r\n    const hasUnderscores = /_{3,}/.test(b.text)\r\n\r\n    return afterLabel && hasUnderscores\r\n  })\r\n\r\n  if (underscoreBlock) {\r\n    return {\r\n      type: \"text_line\",\r\n      position: underscoreBlock.position,\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n\r\n/**\r\n * Create a detected field\r\n */\r\nfunction createDetectedField(\r\n  id: string,\r\n  label: TextBlock,\r\n  input: { type: InputType; position: BoundingBox },\r\n  pageDimensions: { width: number; height: number },\r\n  method: DetectionMethod,\r\n): DetectedField {\r\n  return {\r\n    id,\r\n    label: {\r\n      text: label.text.replace(/:$/, \"\").trim(),\r\n      block_id: label.id,\r\n      position: label.position,\r\n      position_normalized: pdfToNormalized(label.position, pageDimensions),\r\n    },\r\n    input: {\r\n      type: input.type,\r\n      position: input.position,\r\n      position_normalized: pdfToNormalized(input.position, pageDimensions),\r\n      native_field_id: null,\r\n    },\r\n    detection_method: method,\r\n    confidence: calculateConfidence(method, label, input),\r\n    suggested_type: suggestFieldType(label.text),\r\n  }\r\n}\r\n\r\n/**\r\n * Convert line element to bounding box\r\n */\r\nfunction lineToBox(line: LineElement): BoundingBox {\r\n  return {\r\n    x: Math.min(line.start.x, line.end.x),\r\n    y: Math.min(line.start.y, line.end.y),\r\n    width: Math.abs(line.end.x - line.start.x) || 2,\r\n    height: Math.abs(line.end.y - line.start.y) || line.thickness,\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate detection confidence\r\n */\r\nfunction calculateConfidence(\r\n  method: DetectionMethod,\r\n  label: TextBlock,\r\n  input: { type: InputType; position: BoundingBox },\r\n): number {\r\n  let base = 0.5\r\n\r\n  // Method-based adjustment\r\n  switch (method) {\r\n    case \"pdf_native\":\r\n      base = 0.95\r\n      break\r\n    case \"line_detection\":\r\n      base = 0.8\r\n      break\r\n    case \"box_detection\":\r\n      base = 0.85\r\n      break\r\n    case \"pattern_matching\":\r\n      base = 0.7\r\n      break\r\n    case \"ai_vision\":\r\n      base = 0.75\r\n      break\r\n    case \"template_match\":\r\n      base = 0.9\r\n      break\r\n  }\r\n\r\n  // Distance penalty\r\n  const distance = boxDistance(label.position, input.position)\r\n  if (distance > 30) base -= 0.1\r\n  if (distance > 50) base -= 0.1\r\n\r\n  return Math.max(0.3, Math.min(1.0, base))\r\n}\r\n\r\n/**\r\n * Suggest field data type from label\r\n */\r\nfunction suggestFieldType(labelText: string): FieldDataType {\r\n  const lower = labelText.toLowerCase()\r\n\r\n  if (/email/i.test(lower)) return \"email\"\r\n  if (/phone|tel|mobile|cell/i.test(lower)) return \"phone\"\r\n  if (/date|dob|birth/i.test(lower)) return \"date\"\r\n  if (/amount|price|cost|value|total|r\\s?\\d/i.test(lower)) return \"currency\"\r\n  if (/number|no\\.?|#/i.test(lower)) return \"number\"\r\n  if (/signature/i.test(lower)) return \"signature\"\r\n  if (/address/i.test(lower)) return \"address\"\r\n  if (/name/i.test(lower)) return \"name\"\r\n  if (/company|business|organization/i.test(lower)) return \"company\"\r\n  if (/id|identity|registration|vat/i.test(lower)) return \"id_number\"\r\n\r\n  return \"text\"\r\n}\r\n\r\n/**\r\n * Build reading order from text blocks\r\n */\r\nfunction buildReadingOrder(pages: ParsedPage[]): string[] {\r\n  const order: string[] = []\r\n\r\n  pages.forEach((page) => {\r\n    // Sort blocks by position (top to bottom, left to right)\r\n    const sorted = [...page.content.text_blocks].sort((a, b) => {\r\n      // First by Y (top to bottom in normalized coords)\r\n      const yDiff = a.position_normalized.y - b.position_normalized.y\r\n      if (Math.abs(yDiff) > 0.02) return yDiff\r\n\r\n      // Then by X (left to right)\r\n      return a.position_normalized.x - b.position_normalized.x\r\n    })\r\n\r\n    sorted.forEach((block) => order.push(block.id))\r\n  })\r\n\r\n  return order\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - OCR MODULE\r\n// Handles OCR for scanned documents\r\n// ============================================\r\n\r\nimport type { ParsedPage, TextBlock, WordInfo, BoundingBox, FontInfo } from \"../types\"\r\nimport { pdfToNormalized } from \"../utils/position-mapper\"\r\nimport { OCR_CONFIG } from \"../constants\"\r\n\r\nlet TesseractModule: typeof import(\"tesseract.js\") | null = null\r\n\r\nasync function getTesseract() {\r\n  if (!TesseractModule) {\r\n    TesseractModule = await import(\"tesseract.js\")\r\n  }\r\n  return (TesseractModule as any)\r\n}\r\n\r\nexport interface OCRResult {\r\n  pages: OCRPage[]\r\n  confidence: number\r\n  engine: \"tesseract\" | \"google_vision\"\r\n  processingTimeMs: number\r\n}\r\n\r\nexport interface OCRPage {\r\n  pageNumber: number\r\n  text: string\r\n  blocks: OCRBlock[]\r\n  confidence: number\r\n}\r\n\r\nexport interface OCRBlock {\r\n  text: string\r\n  confidence: number\r\n  bounds: BoundingBox\r\n  words: WordInfo[]\r\n}\r\n\r\n/**\r\n * Perform OCR on a page image\r\n */\r\nexport async function performOCR(\r\n  imageData: Buffer | string, // Can be buffer or base64\r\n  pageNumber: number,\r\n  pageDimensions: { width: number; height: number },\r\n  language: string = OCR_CONFIG.default_language,\r\n): Promise<OCRPage> {\r\n  const startTime = Date.now()\r\n\r\n  try {\r\n    const Tesseract = await getTesseract()\r\n\r\n    // Use Tesseract.js for OCR\r\n    const result = await Tesseract.recognize(imageData, language, {\r\n      logger: () => {}, // Suppress logs\r\n    })\r\n\r\n    const blocks: OCRBlock[] = []\r\n\r\n    // Process paragraphs/blocks\r\n    result.data.paragraphs?.forEach((para: any) => {\r\n      const words: WordInfo[] = []\r\n\r\n      para.words?.forEach((word: any) => {\r\n        words.push({\r\n          text: word.text,\r\n          position: {\r\n            x: word.bbox.x0,\r\n            y: pageDimensions.height - word.bbox.y1, // Convert to PDF coords\r\n            width: word.bbox.x1 - word.bbox.x0,\r\n            height: word.bbox.y1 - word.bbox.y0,\r\n          },\r\n          confidence: word.confidence / 100,\r\n        })\r\n      })\r\n\r\n      blocks.push({\r\n        text: para.text,\r\n        confidence: para.confidence / 100,\r\n        bounds: {\r\n          x: para.bbox.x0,\r\n          y: pageDimensions.height - para.bbox.y1,\r\n          width: para.bbox.x1 - para.bbox.x0,\r\n          height: para.bbox.y1 - para.bbox.y0,\r\n        },\r\n        words,\r\n      })\r\n    })\r\n\r\n    return {\r\n      pageNumber,\r\n      text: result.data.text,\r\n      blocks,\r\n      confidence: result.data.confidence / 100,\r\n    }\r\n  } catch (error) {\r\n    console.error(\"OCR failed:\", error)\r\n    return {\r\n      pageNumber,\r\n      text: \"\",\r\n      blocks: [],\r\n      confidence: 0,\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Convert OCR result to TextBlocks\r\n */\r\nexport function ocrToTextBlocks(ocrPage: OCRPage, pageDimensions: { width: number; height: number }): TextBlock[] {\r\n  const textBlocks: TextBlock[] = []\r\n  let lineIndex = 0\r\n  let paragraphIndex = 0\r\n\r\n  ocrPage.blocks.forEach((block, blockIdx) => {\r\n    // Split block into lines\r\n    const lines = block.text.split(\"\\n\").filter((l) => l.trim())\r\n\r\n    lines.forEach((lineText, lineIdx) => {\r\n      // Find words for this line\r\n      const lineWords = block.words.filter((w) => lineText.includes(w.text))\r\n\r\n      const position =\r\n        lineWords.length > 0\r\n          ? {\r\n              x: Math.min(...lineWords.map((w) => w.position.x)),\r\n              y: Math.min(...lineWords.map((w) => w.position.y)),\r\n              width:\r\n                Math.max(...lineWords.map((w) => w.position.x + w.position.width)) -\r\n                Math.min(...lineWords.map((w) => w.position.x)),\r\n              height: Math.max(...lineWords.map((w) => w.position.height)),\r\n            }\r\n          : block.bounds\r\n\r\n      textBlocks.push({\r\n        id: `ocr-${ocrPage.pageNumber}-${blockIdx}-${lineIdx}`,\r\n        text: lineText,\r\n        position,\r\n        position_normalized: pdfToNormalized(position, pageDimensions),\r\n        font: defaultOCRFont(),\r\n        block_type: classifyOCRBlock(lineText, position, pageDimensions),\r\n        line_index: lineIndex++,\r\n        paragraph_index: paragraphIndex,\r\n        confidence: block.confidence,\r\n        words: lineWords.length > 0 ? lineWords : null,\r\n      })\r\n    })\r\n\r\n    paragraphIndex++\r\n  })\r\n\r\n  return textBlocks\r\n}\r\n\r\n/**\r\n * Default font for OCR text (we can't detect actual font)\r\n */\r\nfunction defaultOCRFont(): FontInfo {\r\n  return {\r\n    name: \"unknown\",\r\n    family: null,\r\n    size: 12,\r\n    weight: \"normal\",\r\n    style: \"normal\",\r\n    color: \"#000000\",\r\n  }\r\n}\r\n\r\n/**\r\n * Classify OCR text block type\r\n */\r\nfunction classifyOCRBlock(\r\n  text: string,\r\n  position: BoundingBox,\r\n  pageDimensions: { width: number; height: number },\r\n): TextBlock[\"block_type\"] {\r\n  const normalizedY = position.y / pageDimensions.height\r\n\r\n  // Headers/footers by position\r\n  if (normalizedY > 0.9) return \"header\"\r\n  if (normalizedY < 0.1) return \"footer\"\r\n\r\n  // Page numbers\r\n  if (text.match(/^\\d+$/) && (normalizedY < 0.1 || normalizedY > 0.9)) {\r\n    return \"page_number\"\r\n  }\r\n\r\n  // Labels\r\n  if (text.trim().endsWith(\":\")) return \"label\"\r\n\r\n  // List items\r\n  if (text.match(/^[\\u2022\\u2023\\u25E6\\u2043\\u2219â€¢-]\\s/)) return \"list_item\"\r\n  if (text.match(/^\\d+[.)]\\s/)) return \"list_item\"\r\n\r\n  // All caps might be heading\r\n  if (text === text.toUpperCase() && text.length > 3 && text.length < 100) {\r\n    return \"heading_2\"\r\n  }\r\n\r\n  return \"paragraph\"\r\n}\r\n\r\n/**\r\n * Merge OCR results with existing parsed page\r\n */\r\nexport function mergeOCRWithPage(page: ParsedPage, ocrPage: OCRPage): ParsedPage {\r\n  const ocrBlocks = ocrToTextBlocks(ocrPage, {\r\n    width: page.width,\r\n    height: page.height,\r\n  })\r\n\r\n  return {\r\n    ...page,\r\n    content: {\r\n      ...page.content,\r\n      full_text: ocrPage.text,\r\n      text_blocks: ocrBlocks,\r\n    },\r\n    is_scanned: true,\r\n    ocr_confidence: ocrPage.confidence,\r\n  }\r\n}\r\n\r\n/**\r\n * Render PDF page to image for OCR\r\n * This function creates an image from a PDF page for OCR processing\r\n */\r\nexport async function renderPageToImage(\r\n  pdfPage: any, // pdfjsLib.PDFPageProxy\r\n  scale = 2.0,\r\n): Promise<Buffer> {\r\n  // This requires a canvas implementation\r\n  // In Node.js, we'd use node-canvas or similar\r\n  // For now, return a placeholder - actual implementation depends on environment\r\n\r\n  const viewport = pdfPage.getViewport({ scale })\r\n\r\n  // In browser, we could use canvas:\r\n  // const canvas = document.createElement('canvas')\r\n  // canvas.width = viewport.width\r\n  // canvas.height = viewport.height\r\n  // const context = canvas.getContext('2d')\r\n  // await pdfPage.render({ canvasContext: context, viewport }).promise\r\n  // return canvas.toDataURL('image/png')\r\n\r\n  // In Node.js with node-canvas:\r\n  // const { createCanvas } = require('canvas')\r\n  // const canvas = createCanvas(viewport.width, viewport.height)\r\n  // ...\r\n\r\n  throw new Error(\"Page rendering requires canvas implementation - use in browser or with node-canvas\")\r\n}\r\n\r\n/**\r\n * Check if a page needs OCR\r\n */\r\nexport function pageNeedsOCR(page: ParsedPage): boolean {\r\n  // If page has very little text, it's likely scanned\r\n  const textLength = page.content.full_text.length\r\n  const pageArea = page.width * page.height\r\n\r\n  // Less than 100 characters per 100,000 square points\r\n  const textDensity = textLength / (pageArea / 100000)\r\n\r\n  return textDensity < OCR_CONFIG.min_text_density || page.is_scanned\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - DOCUMENT FINGERPRINTING\r\n// Creates unique identifiers for template matching\r\n// ============================================\r\n\r\nimport crypto from \"crypto\"\r\nimport type { ParsedPage, FormField, TableRegion, DocumentFingerprints } from \"../types\"\r\n\r\n/**\r\n * Generate document fingerprints for template matching\r\n * Fingerprints are based on structure, not content\r\n */\r\nexport function generateFingerprints(\r\n  pages: ParsedPage[],\r\n  formFields: FormField[],\r\n  tableRegions: TableRegion[],\r\n  contentHash: string,\r\n): DocumentFingerprints {\r\n  return {\r\n    structure_hash: generateStructureHash(pages),\r\n    layout_hash: generateLayoutHash(pages),\r\n    form_hash: formFields.length > 0 ? generateFormHash(formFields) : null,\r\n    table_hash: tableRegions.length > 0 ? generateTableHash(tableRegions) : null,\r\n    content_hash: contentHash,\r\n  }\r\n}\r\n\r\n/**\r\n * Generate structure hash based on overall document structure\r\n * - Page count and dimensions\r\n * - Text block distribution per page\r\n * - Section structure\r\n */\r\nfunction generateStructureHash(pages: ParsedPage[]): string {\r\n  const features: string[] = []\r\n\r\n  // Page count\r\n  features.push(`pages:${pages.length}`)\r\n\r\n  // Page dimensions (normalized to common sizes)\r\n  pages.forEach((page, idx) => {\r\n    const sizeClass = classifyPageSize(page.width, page.height)\r\n    const orientation = page.width > page.height ? \"landscape\" : \"portrait\"\r\n    features.push(`p${idx}:${sizeClass}:${orientation}`)\r\n  })\r\n\r\n  // Text density per page (binned)\r\n  pages.forEach((page, idx) => {\r\n    const blockCount = page.content.text_blocks.length\r\n    const densityBin = Math.floor(blockCount / 10) * 10 // Bin by 10s\r\n    features.push(`p${idx}:blocks:${densityBin}`)\r\n  })\r\n\r\n  // Heading structure\r\n  pages.forEach((page, idx) => {\r\n    const headings = page.content.text_blocks.filter((b) => b.block_type.startsWith(\"heading\")).length\r\n    features.push(`p${idx}:headings:${headings}`)\r\n  })\r\n\r\n  return hashString(features.join(\"|\"))\r\n}\r\n\r\n/**\r\n * Generate layout hash based on visual layout\r\n * - Margins and whitespace\r\n * - Column structure\r\n * - Visual regions\r\n */\r\nfunction generateLayoutHash(pages: ParsedPage[]): string {\r\n  const features: string[] = []\r\n\r\n  pages.forEach((page, idx) => {\r\n    // Estimate margins from text block positions\r\n    const blocks = page.content.text_blocks\r\n    if (blocks.length === 0) {\r\n      features.push(`p${idx}:empty`)\r\n      return\r\n    }\r\n\r\n    const leftMargin = Math.min(...blocks.map((b) => b.position_normalized.x))\r\n    const rightMargin = 1 - Math.max(...blocks.map((b) => b.position_normalized.x + b.position_normalized.width))\r\n    const topMargin = Math.min(...blocks.map((b) => b.position_normalized.y))\r\n\r\n    // Bin margins (0-10%, 10-20%, etc.)\r\n    const leftBin = Math.floor(leftMargin * 10)\r\n    const rightBin = Math.floor(rightMargin * 10)\r\n    const topBin = Math.floor(topMargin * 10)\r\n\r\n    features.push(`p${idx}:margins:${leftBin}:${rightBin}:${topBin}`)\r\n\r\n    // Detect columns (simple heuristic based on x-position clustering)\r\n    const xPositions = blocks.map((b) => b.position_normalized.x)\r\n    const columnCount = estimateColumnCount(xPositions)\r\n    features.push(`p${idx}:cols:${columnCount}`)\r\n  })\r\n\r\n  return hashString(features.join(\"|\"))\r\n}\r\n\r\n/**\r\n * Generate form hash based on form field positions\r\n */\r\nfunction generateFormHash(fields: FormField[]): string {\r\n  const features: string[] = []\r\n\r\n  // Field count by type\r\n  const typeCounts: Record<string, number> = {}\r\n  fields.forEach((f) => {\r\n    typeCounts[f.type] = (typeCounts[f.type] || 0) + 1\r\n  })\r\n  Object.entries(typeCounts)\r\n    .sort()\r\n    .forEach(([type, count]) => {\r\n      features.push(`type:${type}:${count}`)\r\n    })\r\n\r\n  // Field positions (binned to grid)\r\n  fields.forEach((field, idx) => {\r\n    const xBin = Math.floor(field.position_normalized.x * 10)\r\n    const yBin = Math.floor(field.position_normalized.y * 10)\r\n    features.push(`f${idx}:${field.page}:${xBin}:${yBin}`)\r\n  })\r\n\r\n  return hashString(features.join(\"|\"))\r\n}\r\n\r\n/**\r\n * Generate table hash based on table structures\r\n */\r\nfunction generateTableHash(tables: TableRegion[]): string {\r\n  const features: string[] = []\r\n\r\n  // Table count\r\n  features.push(`count:${tables.length}`)\r\n\r\n  // Table structures\r\n  tables.forEach((table, idx) => {\r\n    features.push(`t${idx}:${table.page}:${table.row_count_estimate}x${table.column_count_estimate}`)\r\n    const xBin = Math.floor(table.position_normalized.x * 10)\r\n    const yBin = Math.floor(table.position_normalized.y * 10)\r\n    features.push(`t${idx}:pos:${xBin}:${yBin}`)\r\n  })\r\n\r\n  return hashString(features.join(\"|\"))\r\n}\r\n\r\n/**\r\n * Generate content hash (for detecting identical documents)\r\n */\r\nexport function generateContentHash(text: string): string {\r\n  return hashString(text.toLowerCase().replace(/\\s+/g, \" \").trim())\r\n}\r\n\r\n/**\r\n * Calculate similarity score between two fingerprints\r\n * Returns 0-1 where 1 is identical\r\n */\r\nexport function calculateFingerprintSimilarity(a: DocumentFingerprints, b: DocumentFingerprints): number {\r\n  let totalWeight = 0\r\n  let weightedScore = 0\r\n\r\n  // Structure hash - most important (weight: 40%)\r\n  if (a.structure_hash === b.structure_hash) {\r\n    weightedScore += 0.4\r\n  }\r\n  totalWeight += 0.4\r\n\r\n  // Layout hash (weight: 25%)\r\n  if (a.layout_hash === b.layout_hash) {\r\n    weightedScore += 0.25\r\n  }\r\n  totalWeight += 0.25\r\n\r\n  // Form hash (weight: 25%) - only if both have forms\r\n  if (a.form_hash && b.form_hash) {\r\n    if (a.form_hash === b.form_hash) {\r\n      weightedScore += 0.25\r\n    }\r\n    totalWeight += 0.25\r\n  }\r\n\r\n  // Table hash (weight: 10%) - only if both have tables\r\n  if (a.table_hash && b.table_hash) {\r\n    if (a.table_hash === b.table_hash) {\r\n      weightedScore += 0.1\r\n    }\r\n    totalWeight += 0.1\r\n  }\r\n\r\n  return weightedScore / totalWeight\r\n}\r\n\r\n// Helper functions\r\n\r\nfunction hashString(str: string): string {\r\n  return crypto.createHash(\"sha256\").update(str).digest(\"hex\").substring(0, 16)\r\n}\r\n\r\nfunction classifyPageSize(width: number, height: number): string {\r\n  // Common page sizes in points\r\n  const sizes = {\r\n    a4: { w: 595, h: 842 },\r\n    letter: { w: 612, h: 792 },\r\n    legal: { w: 612, h: 1008 },\r\n    a3: { w: 842, h: 1191 },\r\n  }\r\n\r\n  const tolerance = 20 // Points tolerance\r\n\r\n  for (const [name, size] of Object.entries(sizes)) {\r\n    if (\r\n      (Math.abs(width - size.w) < tolerance && Math.abs(height - size.h) < tolerance) ||\r\n      (Math.abs(width - size.h) < tolerance && Math.abs(height - size.w) < tolerance)\r\n    ) {\r\n      return name\r\n    }\r\n  }\r\n\r\n  return \"custom\"\r\n}\r\n\r\nfunction estimateColumnCount(xPositions: number[]): number {\r\n  if (xPositions.length === 0) return 0\r\n\r\n  // Simple clustering based on x-position gaps\r\n  const sorted = [...xPositions].sort((a, b) => a - b)\r\n  const gaps: number[] = []\r\n\r\n  for (let i = 1; i < sorted.length; i++) {\r\n    gaps.push(sorted[i] - sorted[i - 1])\r\n  }\r\n\r\n  // Count significant gaps (> 0.2 of page width)\r\n  const significantGaps = gaps.filter((g) => g > 0.2).length\r\n\r\n  return Math.min(significantGaps + 1, 4) // Cap at 4 columns\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - INPUT VALIDATION\r\n// ============================================\r\n\r\nimport type { ParseRequest, ParseOptions, DocuMindError } from \"../types\"\r\nimport { Errors } from \"../errors\"\r\nimport { MAX_FILE_SIZE, MAX_PAGES, SUPPORTED_MIME_TYPES, type SupportedMimeType } from \"../constants\"\r\n\r\nexport interface ValidationResult {\r\n  valid: boolean\r\n  error?: DocuMindError\r\n}\r\n\r\n/**\r\n * Validate a parse request\r\n */\r\nexport function validateParseRequest(request: ParseRequest): ValidationResult {\r\n  // Must have at least one input source\r\n  if (!request.file && !request.url && !request.base64) {\r\n    return {\r\n      valid: false,\r\n      error: Errors.invalidRequest(\"Must provide one of: file, url, or base64\"),\r\n    }\r\n  }\r\n\r\n  // Only one input source allowed\r\n  const inputCount = [request.file, request.url, request.base64].filter(Boolean).length\r\n  if (inputCount > 1) {\r\n    return {\r\n      valid: false,\r\n      error: Errors.invalidRequest(\"Only one input source allowed (file, url, or base64)\"),\r\n    }\r\n  }\r\n\r\n  // Validate app_id\r\n  if (!request.app_id || request.app_id.trim() === \"\") {\r\n    return {\r\n      valid: false,\r\n      error: Errors.missingRequiredField(\"app_id\"),\r\n    }\r\n  }\r\n\r\n  // Validate options if provided\r\n  if (request.options) {\r\n    const optionsResult = validateParseOptions(request.options)\r\n    if (!optionsResult.valid) {\r\n      return optionsResult\r\n    }\r\n  }\r\n\r\n  // Validate webhook URL if provided\r\n  if (request.webhook_url) {\r\n    try {\r\n      new URL(request.webhook_url)\r\n    } catch {\r\n      return {\r\n        valid: false,\r\n        error: Errors.invalidOptions(\"webhook_url\", \"Invalid URL format\"),\r\n      }\r\n    }\r\n  }\r\n\r\n  return { valid: true }\r\n}\r\n\r\n/**\r\n * Validate parse options\r\n */\r\nexport function validateParseOptions(options: ParseOptions): ValidationResult {\r\n  // Validate max_pages\r\n  if (options.max_pages !== undefined) {\r\n    if (options.max_pages < 1 || options.max_pages > MAX_PAGES) {\r\n      return {\r\n        valid: false,\r\n        error: Errors.invalidOptions(\"max_pages\", `Must be between 1 and ${MAX_PAGES}`),\r\n      }\r\n    }\r\n  }\r\n\r\n  // Validate priority\r\n  if (options.priority !== undefined) {\r\n    if (![\"low\", \"normal\", \"high\"].includes(options.priority)) {\r\n      return {\r\n        valid: false,\r\n        error: Errors.invalidOptions(\"priority\", \"Must be 'low', 'normal', or 'high'\"),\r\n      }\r\n    }\r\n  }\r\n\r\n  // Validate OCR language\r\n  if (options.ocr_language !== undefined) {\r\n    const validLanguages = [\"en\", \"eng\", \"afr\", \"zul\", \"xho\", \"sot\", \"tsn\"]\r\n    if (!validLanguages.includes(options.ocr_language)) {\r\n      return {\r\n        valid: false,\r\n        error: Errors.invalidOptions(\"ocr_language\", `Supported languages: ${validLanguages.join(\", \")}`),\r\n      }\r\n    }\r\n  }\r\n\r\n  return { valid: true }\r\n}\r\n\r\n/**\r\n * Validate file metadata\r\n */\r\nexport function validateFile(mimeType: string, size: number): ValidationResult {\r\n  // Check file size\r\n  if (size > MAX_FILE_SIZE) {\r\n    return {\r\n      valid: false,\r\n      error: Errors.fileTooLarge(MAX_FILE_SIZE, size),\r\n    }\r\n  }\r\n\r\n  // Check MIME type\r\n  if (!SUPPORTED_MIME_TYPES.includes(mimeType as SupportedMimeType)) {\r\n    return {\r\n      valid: false,\r\n      error: Errors.unsupportedFormat(mimeType),\r\n    }\r\n  }\r\n\r\n  return { valid: true }\r\n}\r\n\r\n/**\r\n * Detect MIME type from file header (magic bytes)\r\n */\r\nexport function detectMimeType(buffer: Buffer): string | null {\r\n  // Check first bytes for magic numbers\r\n  const header = buffer.slice(0, 8)\r\n\r\n  // PDF: %PDF\r\n  if (header[0] === 0x25 && header[1] === 0x50 && header[2] === 0x44 && header[3] === 0x46) {\r\n    return \"application/pdf\"\r\n  }\r\n\r\n  // PNG: 89 50 4E 47\r\n  if (header[0] === 0x89 && header[1] === 0x50 && header[2] === 0x4e && header[3] === 0x47) {\r\n    return \"image/png\"\r\n  }\r\n\r\n  // JPEG: FF D8 FF\r\n  if (header[0] === 0xff && header[1] === 0xd8 && header[2] === 0xff) {\r\n    return \"image/jpeg\"\r\n  }\r\n\r\n  // TIFF: 49 49 2A 00 (little-endian) or 4D 4D 00 2A (big-endian)\r\n  if (\r\n    (header[0] === 0x49 && header[1] === 0x49 && header[2] === 0x2a && header[3] === 0x00) ||\r\n    (header[0] === 0x4d && header[1] === 0x4d && header[2] === 0x00 && header[3] === 0x2a)\r\n  ) {\r\n    return \"image/tiff\"\r\n  }\r\n\r\n  // DOCX: PK (ZIP archive) - need additional check\r\n  if (header[0] === 0x50 && header[1] === 0x4b) {\r\n    // Could be docx, xlsx, etc. - needs content inspection\r\n    return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"\r\n  }\r\n\r\n  // DOC: D0 CF 11 E0 (OLE compound)\r\n  if (header[0] === 0xd0 && header[1] === 0xcf && header[2] === 0x11 && header[3] === 0xe0) {\r\n    return \"application/msword\"\r\n  }\r\n\r\n  return null\r\n}\r\n\r\n/**\r\n * Sanitize filename for storage\r\n */\r\nexport function sanitizeFilename(filename: string): string {\r\n  // Remove path separators and dangerous characters\r\n  return filename\r\n    .replace(/[/\\\\:*?\"<>|]/g, \"_\")\r\n    .replace(/\\.\\./g, \"_\")\r\n    .replace(/^\\./, \"_\")\r\n    .substring(0, 255)\r\n}\r\n\r\n/**\r\n * Generate a unique document ID\r\n */\r\nexport function generateDocumentId(): string {\r\n  return crypto.randomUUID()\r\n}\r\n\r\n/**\r\n * Validate UUID format\r\n */\r\nexport function isValidUUID(str: string): boolean {\r\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\r\n  return uuidRegex.test(str)\r\n}\r\n","// ============================================\r\n// DOCUMIND ENGINE - MAIN ENTRY POINT\r\n// ============================================\r\n\r\nexport * from \"./types\"\r\nexport * from \"./errors\"\r\nexport * from \"./constants\"\r\n\r\n// Modules\r\nexport { parsePDF, type PDFParseResult, type PDFParseOptions } from \"./modules/pdf-parser\"\r\nexport { analyzeLayout, type LayoutAnalysisResult } from \"./modules/layout-analyzer\"\r\nexport { performOCR, mergeOCRWithPage, pageNeedsOCR, type OCRResult, type OCRPage } from \"./modules/ocr-engine\"\r\n\r\n// Utils\r\nexport * from \"./utils/position-mapper\"\r\nexport * from \"./utils/fingerprint\"\r\nexport * from \"./utils/validation\"\r\n\r\n// Main processing function\r\nimport { parsePDF } from \"./modules/pdf-parser\"\r\nimport { analyzeLayout } from \"./modules/layout-analyzer\"\r\nimport { pageNeedsOCR } from \"./modules/ocr-engine\"\r\nimport { generateFingerprints, generateContentHash } from \"./utils/fingerprint\"\r\nimport { validateFile } from \"./utils/validation\"\r\nimport { Errors } from \"./errors\"\r\nimport type { ParsedDocument, ParseOptions, DocuMindError, ProcessingInfo } from \"./types\"\r\n\r\nexport interface ProcessDocumentResult {\r\n  success: boolean\r\n  document?: ParsedDocument\r\n  error?: DocuMindError\r\n}\r\n\r\n/**\r\n * Main document processing function\r\n * Orchestrates parsing, OCR, layout analysis, and fingerprinting\r\n */\r\nexport async function processDocument(\r\n  data: ArrayBuffer | Uint8Array,\r\n  mimeType: string,\r\n  options: ParseOptions = {},\r\n): Promise<ProcessDocumentResult> {\r\n  const startTime = Date.now()\r\n  const warnings: string[] = []\r\n\r\n  try {\r\n    // Validate file\r\n    const fileValidation = validateFile(mimeType, data.byteLength)\r\n    if (!fileValidation.valid) {\r\n      return { success: false, error: fileValidation.error }\r\n    }\r\n\r\n    // Currently only supporting PDF\r\n    if (mimeType !== \"application/pdf\") {\r\n      return {\r\n        success: false,\r\n        error: Errors.unsupportedFormat(mimeType),\r\n      }\r\n    }\r\n\r\n    // Parse PDF\r\n    const parseResult = await parsePDF(data, {\r\n      extractImages: options.extract_images,\r\n      maxPages: options.max_pages,\r\n      password: options.password,\r\n    })\r\n\r\n    const pages = parseResult.pages\r\n    let ocrUsed = false\r\n    const ocrConfidence: number | null = null\r\n\r\n    // Perform OCR on scanned pages if enabled\r\n    if (options.ocr_enabled !== false) {\r\n      for (let i = 0; i < pages.length; i++) {\r\n        if (pageNeedsOCR(pages[i])) {\r\n          warnings.push(`Page ${i + 1} appears to be scanned, OCR required`)\r\n          // Note: Full OCR implementation would render page to image first\r\n          // For now, mark as needing OCR\r\n          ocrUsed = true\r\n        }\r\n      }\r\n    }\r\n\r\n    // Analyze layout\r\n    const layoutResult = analyzeLayout(pages, parseResult.metadata.detected_type)\r\n\r\n    // Generate fingerprints\r\n    const contentHash = generateContentHash(parseResult.rawText)\r\n    const fingerprints = generateFingerprints(pages, parseResult.formFields, layoutResult.tableRegions, contentHash)\r\n\r\n    // Build processing info\r\n    const processingInfo: ProcessingInfo = {\r\n      duration_ms: Date.now() - startTime,\r\n      ocr_used: ocrUsed,\r\n      ocr_engine: ocrUsed ? \"tesseract\" : null,\r\n      ocr_confidence: ocrConfidence,\r\n      warnings,\r\n      pages_processed: pages.length,\r\n      pages_skipped: (options.max_pages || 0) > 0 ? Math.max(0, parseResult.metadata.page_count - pages.length) : 0,\r\n    }\r\n\r\n    // Build final document\r\n    const document: ParsedDocument = {\r\n      document_id: crypto.randomUUID(),\r\n      status: warnings.length > 0 ? \"partial\" : \"complete\",\r\n      metadata: parseResult.metadata,\r\n      fingerprints,\r\n      pages,\r\n      layout: layoutResult.layout,\r\n      form_fields: parseResult.formFields,\r\n      processing: processingInfo,\r\n    }\r\n\r\n    return { success: true, document }\r\n  } catch (error) {\r\n    console.error(\"Document processing error:\", error)\r\n    return {\r\n      success: false,\r\n      error: Errors.parseFailed(\"unknown\", error instanceof Error ? error.message : \"Unknown error\"),\r\n    }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}